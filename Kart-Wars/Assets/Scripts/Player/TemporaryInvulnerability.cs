using UnityEngine;
using Mirror;
using System.Collections;

/// <summary>
/// Networked invulnerability with visual blink effect and server-controlled timers.
/// </summary>
public class TemporaryInvulnerability : NetworkBehaviour
{
    [Header("Settings")]
    [SerializeField] private float defaultDuration = 3f;
    [SerializeField] private float blinkRate = 10f;

    [Header("Visual")]
    [SerializeField] private MeshRenderer[] meshRenderers;
    [SerializeField] private Color invulnerableColor = new Color(1f, 1f, 1f, 0.5f);

    [Header("Audio")]
    [SerializeField] private AudioClip invulnerableStartSound;
    [SerializeField] private AudioClip invulnerableEndSound;

    [SyncVar(hook = nameof(OnInvulnerableChanged))]
    private bool isInvulnerable = false;

    public bool IsInvulnerable => isInvulnerable;

    public event System.Action<bool> OnInvulnerabilityChanged;

    private Coroutine invulnerabilityCoroutine;
    private Coroutine blinkCoroutine;
    private Color[] originalColors;
    private bool blinkState = true;

    private void Awake()
    {
        // Store original colors
        if (meshRenderers != null && meshRenderers.Length > 0)
        {
            originalColors = new Color[meshRenderers.Length];
            for (int i = 0; i < meshRenderers.Length; i++)
            {
                if (meshRenderers[i] != null)
                {
                    originalColors[i] = meshRenderers[i].material.color;
                }
            }
        }
    }

    /// <summary>
    /// Start invulnerability with default duration (server only)
    /// </summary>
    [Server]
    public void StartInvulnerability()
    {
        StartInvulnerability(defaultDuration);
    }

    /// <summary>
    /// Start invulnerability with custom duration (server only)
    /// </summary>
    [Server]
    public void StartInvulnerability(float duration)
    {
        if (invulnerabilityCoroutine != null)
        {
            StopCoroutine(invulnerabilityCoroutine);
        }

        isInvulnerable = true;
        invulnerabilityCoroutine = StartCoroutine(InvulnerabilityTimer(duration));
    }

    /// <summary>
    /// End invulnerability immediately (server only)
    /// </summary>
    [Server]
    public void EndInvulnerability()
    {
        if (invulnerabilityCoroutine != null)
        {
            StopCoroutine(invulnerabilityCoroutine);
            invulnerabilityCoroutine = null;
        }

        isInvulnerable = false;
    }

    [Server]
    private IEnumerator InvulnerabilityTimer(float duration)
    {
        yield return new WaitForSeconds(duration);
        isInvulnerable = false;
        invulnerabilityCoroutine = null;
    }

    private void OnInvulnerableChanged(bool oldValue, bool newValue)
    {
        OnInvulnerabilityChanged?.Invoke(newValue);

        if (newValue)
        {
            StartBlinking();
            if (invulnerableStartSound != null)
            {
                AudioSource.PlayClipAtPoint(invulnerableStartSound, transform.position);
            }
        }
        else
        {
            StopBlinking();
            if (invulnerableEndSound != null)
            {
                AudioSource.PlayClipAtPoint(invulnerableEndSound, transform.position);
            }
        }
    }

    private void StartBlinking()
    {
        if (blinkCoroutine != null)
        {
            StopCoroutine(blinkCoroutine);
        }
        blinkCoroutine = StartCoroutine(BlinkEffect());
    }

    private void StopBlinking()
    {
        if (blinkCoroutine != null)
        {
            StopCoroutine(blinkCoroutine);
            blinkCoroutine = null;
        }

        // Restore original colors
        RestoreColors();
    }

    private IEnumerator BlinkEffect()
    {
        float interval = 1f / blinkRate;

        while (isInvulnerable)
        {
            blinkState = !blinkState;

            for (int i = 0; i < meshRenderers.Length; i++)
            {
                if (meshRenderers[i] != null)
                {
                    if (blinkState)
                    {
                        meshRenderers[i].material.color = invulnerableColor;
                    }
                    else
                    {
                        meshRenderers[i].material.color = originalColors[i];
                    }
                }
            }

            yield return new WaitForSeconds(interval);
        }

        RestoreColors();
    }

    private void RestoreColors()
    {
        if (meshRenderers == null || originalColors == null) return;

        for (int i = 0; i < meshRenderers.Length; i++)
        {
            if (meshRenderers[i] != null && i < originalColors.Length)
            {
                meshRenderers[i].material.color = originalColors[i];
            }
        }
    }

    private void OnDisable()
    {
        StopBlinking();
    }
}
